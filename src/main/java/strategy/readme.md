
## linkes

1, https://www.cnblogs.com/jiujiduilie/p/9191629.html

### 一个依托于spring环境的实现
2, https://juejin.im/post/5d12228de51d45775c73dd1b

### 本demo采用下面这个，实战中，建议采用2，和spring关联起来用
3, https://blog.csdn.net/SkipperKevin/article/details/77370880

注意，对3中原版的代码进行的删减，strategy本身无需strategy了

使用场景，

1，计算某个图形的面积，体积，传入图形的编码，以及对应的计算公式

2，按照付款方式的不同，计算手续费

3，同样退款的时候，根据付款方式，进行扣除不同收付费以及退费处理

问题：

1，其实发现策略只是将if -else ，抽取到了enum或者map中，转成了码表
并没有什么高深的东西，

2，策略和SPI，dubbo的插件主要实现方式，目前看起来，有点类似，都是基于接口编程，

## 小结

策略模式，是一种定义一系列算法的方法。从概念上来看，这些所有的算法完成的工作都是相同的，只是实现不同
，他可以以相同的方式调用所有的算法，减少了各种算法类和使用类之间的耦合。

策略模式的Strategy类层次为Context定义了一系列可供重用的算法或者行为，继承有助于析取处这些方法的公共功能。

公共功能，就是获得结果，这样才有了抽象父类，其方法就是获取这个结果。

还有就是简化了单元测试，每个算法都有自己的类，可以通过自己的接口单独测试。

每个算法可保证他没有错误，修改其中任何一个都不会影响其他。

对于策略，多数情况，是将if else分支打散到Map或者Enum中去，甚至switch语句中去。

当不同的行为堆砌在一个类中的时候，很难避免使用条件语句来选择合适的行为，将这些行为封装在一个独立的Strategy类中去，
可以在使用这些行为的类中消除条件语句。

选择基本的策略，在选择具体实现的职责的时候由客户端对象承担，并且转给策略模式的Context对象。 这个本身并没有接触客户端需要选择
判断的压力，而策略与工厂集合之后，选择具体的实现职责由Context来实现，最大程度减轻了客户端的职责。

